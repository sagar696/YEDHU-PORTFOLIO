{"ast":null,"code":"import parsePhoneNumber_, { getCountryCallingCode, AsYouType, Metadata } from 'libphonenumber-js/core';\nimport getInternationalPhoneNumberPrefix from './getInternationalPhoneNumberPrefix.js';\n/**\r\n * Decides which country should be pre-selected\r\n * when the phone number input component is first mounted.\r\n * @param  {object?} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {string?} country - Pre-defined country (two-letter code).\r\n * @param  {string[]?} countries - A list of countries available.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string?}\r\n */\n\nexport function getPreSelectedCountry(_ref) {\n  var value = _ref.value,\n    phoneNumber = _ref.phoneNumber,\n    defaultCountry = _ref.defaultCountry,\n    getAnyCountry = _ref.getAnyCountry,\n    countries = _ref.countries,\n    required = _ref.required,\n    metadata = _ref.metadata;\n  var country; // If can get country from E.164 phone number\n  // then it overrides the `country` passed (or not passed).\n\n  if (phoneNumber && phoneNumber.country) {\n    // `country` will be left `undefined` in case of non-detection.\n    country = phoneNumber.country;\n  } else if (defaultCountry) {\n    if (!value || couldNumberBelongToCountry(value, defaultCountry, metadata)) {\n      country = defaultCountry;\n    }\n  } // Only pre-select a country if it's in the available `countries` list.\n\n  if (countries && countries.indexOf(country) < 0) {\n    country = undefined;\n  } // If there will be no \"International\" option\n  // then some `country` must be selected.\n  // It will still be the wrong country though.\n  // But still country `<select/>` can't be left in a broken state.\n\n  if (!country && required && countries && countries.length > 0) {\n    country = getAnyCountry(); // noCountryMatchesTheNumber = true\n  }\n\n  return country;\n}\n/**\r\n * Generates a sorted list of country `<select/>` options.\r\n * @param  {string[]} countries - A list of two-letter (\"ISO 3166-1 alpha-2\") country codes.\r\n * @param  {object} labels - Custom country labels. E.g. `{ RU: 'Россия', US: 'США', ... }`.\r\n * @param  {boolean} addInternationalOption - Whether should include \"International\" option at the top of the list.\r\n * @return {object[]} A list of objects having shape `{ value : string, label : string }`.\r\n */\n\nexport function getCountrySelectOptions(_ref2) {\n  var countries = _ref2.countries,\n    countryNames = _ref2.countryNames,\n    addInternationalOption = _ref2.addInternationalOption,\n    compareStringsLocales = _ref2.compareStringsLocales,\n    _compareStrings = _ref2.compareStrings;\n\n  // Default country name comparator uses `String.localeCompare()`.\n  if (!_compareStrings) {\n    _compareStrings = compareStrings;\n  } // Generates a `<Select/>` option for each country.\n\n  var countrySelectOptions = countries.map(function (country) {\n    return {\n      value: country,\n      // All `locale` country names included in this library\n      // include all countries (this is checked at build time).\n      // The only case when a country name might be missing\n      // is when a developer supplies their own `labels` property.\n      // To guard against such cases, a missing country name\n      // is substituted by country code.\n      label: countryNames[country] || country\n    };\n  }); // Sort the list of countries alphabetically.\n\n  countrySelectOptions.sort(function (a, b) {\n    return _compareStrings(a.label, b.label, compareStringsLocales);\n  }); // Add the \"International\" option to the country list (if suitable)\n\n  if (addInternationalOption) {\n    countrySelectOptions.unshift({\n      label: countryNames.ZZ\n    });\n  }\n  return countrySelectOptions;\n}\n/**\r\n * Parses a E.164 phone number to an instance of `PhoneNumber` class.\r\n * @param {string?} value = E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {object} Object having shape `{ country: string?, countryCallingCode: string, number: string }`. `PhoneNumber`: https://gitlab.com/catamphetamine/libphonenumber-js#phonenumber.\r\n * @example\r\n * parsePhoneNumber('+78005553535')\r\n */\n\nexport function parsePhoneNumber(value, metadata) {\n  return parsePhoneNumber_(value || '', metadata);\n}\n/**\r\n * Generates national number digits for a parsed phone.\r\n * May prepend national prefix.\r\n * The phone number must be a complete and valid phone number.\r\n * @param  {object} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string}\r\n * @example\r\n * getNationalNumberDigits({ country: 'RU', phone: '8005553535' })\r\n * // returns '88005553535'\r\n */\n\nexport function generateNationalNumberDigits(phoneNumber) {\n  return phoneNumber.formatNational().replace(/\\D/g, '');\n}\n/**\r\n * Migrates parsed `<input/>` `value` for the newly selected `country`.\r\n * @param {string?} phoneDigits - Phone number digits (and `+`) parsed from phone number `<input/>` (it's not the same as the `value` property).\r\n * @param {string?} prevCountry - Previously selected country.\r\n * @param {string?} newCountry - Newly selected country. Can't be same as previously selected country.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @param {boolean} useNationalFormat - whether should attempt to convert from international to national number for the new country.\r\n * @return {string?}\r\n */\n\nexport function getPhoneDigitsForNewCountry(phoneDigits, _ref3) {\n  var prevCountry = _ref3.prevCountry,\n    newCountry = _ref3.newCountry,\n    metadata = _ref3.metadata,\n    useNationalFormat = _ref3.useNationalFormat;\n  if (prevCountry === newCountry) {\n    return phoneDigits;\n  } // If `parsed_input` is empty\n  // then no need to migrate anything.\n\n  if (!phoneDigits) {\n    if (useNationalFormat) {\n      return '';\n    } else {\n      // If `phoneDigits` is empty then set `phoneDigits` to\n      // `+{getCountryCallingCode(newCountry)}`.\n      return getInternationalPhoneNumberPrefix(newCountry, metadata);\n    }\n  } // If switching to some country.\n  // (from \"International\" or another country)\n  // If switching from \"International\" then `phoneDigits` starts with a `+`.\n  // Otherwise it may or may not start with a `+`.\n\n  if (newCountry) {\n    // If the phone number was entered in international format\n    // then migrate it to the newly selected country.\n    // The phone number may be incomplete.\n    // The phone number entered not necessarily starts with\n    // the previously selected country phone prefix.\n    if (phoneDigits[0] === '+') {\n      // If the international phone number is for the new country\n      // then convert it to local if required.\n      if (useNationalFormat) {\n        // // If a phone number is being input in international form\n        // // and the country can already be derived from it,\n        // // and if it is the new country, then format as a national number.\n        // const derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(phoneDigits, metadata)\n        // if (derived_country === newCountry) {\n        // \treturn stripCountryCallingCode(phoneDigits, derived_country, metadata)\n        // }\n        // Actually, the two countries don't necessarily need to match:\n        // the condition could be looser here, because several countries\n        // might share the same international phone number format\n        // (for example, \"NANPA\" countries like US, Canada, etc).\n        // The looser condition would be just \"same nternational phone number format\"\n        // which would mean \"same country calling code\" in the context of `libphonenumber-js`.\n        if (phoneDigits.indexOf('+' + getCountryCallingCode(newCountry, metadata)) === 0) {\n          return stripCountryCallingCode(phoneDigits, newCountry, metadata);\n        } // Simply discard the previously entered international phone number,\n        // because otherwise any \"smart\" transformation like getting the\n        // \"national (significant) number\" part and then prepending the\n        // newly selected country's \"country calling code\" to it\n        // would just be confusing for a user without being actually useful.\n\n        return ''; // // Simply strip the leading `+` character\n        // // therefore simply converting all digits into a \"local\" phone number.\n        // // https://github.com/catamphetamine/react-phone-number-input/issues/287\n        // return phoneDigits.slice(1)\n      }\n\n      if (prevCountry) {\n        var newCountryPrefix = getInternationalPhoneNumberPrefix(newCountry, metadata);\n        if (phoneDigits.indexOf(newCountryPrefix) === 0) {\n          return phoneDigits;\n        } else {\n          return newCountryPrefix;\n        }\n      } else {\n        var defaultValue = getInternationalPhoneNumberPrefix(newCountry, metadata); // If `phoneDigits`'s country calling code part is the same\n        // as for the new `country`, then leave `phoneDigits` as is.\n\n        if (phoneDigits.indexOf(defaultValue) === 0) {\n          return phoneDigits;\n        } // If `phoneDigits`'s country calling code part is not the same\n        // as for the new `country`, then set `phoneDigits` to\n        // `+{getCountryCallingCode(newCountry)}`.\n\n        return defaultValue;\n      } // // If the international phone number already contains\n      // // any country calling code then trim the country calling code part.\n      // // (that could also be the newly selected country phone code prefix as well)\n      // // `phoneDigits` doesn't neccessarily belong to `prevCountry`.\n      // // (e.g. if a user enters an international number\n      // //  not belonging to any of the reduced `countries` list).\n      // phoneDigits = stripCountryCallingCode(phoneDigits, prevCountry, metadata)\n      // // Prepend country calling code prefix\n      // // for the newly selected country.\n      // return e164(phoneDigits, newCountry, metadata) || `+${getCountryCallingCode(newCountry, metadata)}`\n    }\n  } // If switching to \"International\" from a country.\n  else {\n    // If the phone number was entered in national format.\n    if (phoneDigits[0] !== '+') {\n      // Format the national phone number as an international one.\n      // The phone number entered not necessarily even starts with\n      // the previously selected country phone prefix.\n      // Even if the phone number belongs to whole another country\n      // it will still be parsed into some national phone number.\n      //\n      // Ignore the now-uncovered `|| ''` code branch:\n      // previously `e164()` function could return an empty string\n      // even when `phoneDigits` were not empty.\n      // Now it always returns some `value` when there're any `phoneDigits`.\n      // Still, didn't remove the `|| ''` code branch just in case\n      // that logic changes somehow in some future, so there're no\n      // possible bugs related to that.\n      //\n      // (ignore the `|| ''` code branch)\n\n      /* istanbul ignore next */\n      return e164(phoneDigits, prevCountry, metadata) || '';\n    }\n  }\n  return phoneDigits;\n}\n/**\r\n * Converts phone number digits to a (possibly incomplete) E.164 phone number.\r\n * @param  {string?} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string?} country\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\nexport function e164(number, country, metadata) {\n  if (!number) {\n    return;\n  } // If the phone number is being input in international format.\n\n  if (number[0] === '+') {\n    // If it's just the `+` sign then return nothing.\n    if (number === '+') {\n      return;\n    } // Return a E.164 phone number.\n    //\n    // Could return `number` \"as is\" here, but there's a possibility\n    // that some user might incorrectly input an international number\n    // with a \"national prefix\". Such numbers aren't considered valid,\n    // but `libphonenumber-js` is \"forgiving\" when it comes to parsing\n    // user's input, and this input component follows that behavior.\n    //\n\n    var asYouType = new AsYouType(country, metadata);\n    asYouType.input(number); // This function would return `undefined` only when `number` is `\"+\"`,\n    // but at this point it is known that `number` is not `\"+\"`.\n\n    return asYouType.getNumberValue();\n  } // For non-international phone numbers\n  // an accompanying country code is required.\n  // The situation when `country` is `undefined`\n  // and a non-international phone number is passed\n  // to this function shouldn't happen.\n\n  if (!country) {\n    return;\n  }\n  var partial_national_significant_number = getNationalSignificantNumberDigits(number, country, metadata); //\n  // Even if no \"national (significant) number\" digits have been input,\n  // still return a non-`undefined` value.\n  // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/113\n  //\n  // For example, if the user has selected country `US` and entered `\"1\"`\n  // then that `\"1\"` is just a \"national prefix\" and no \"national (significant) number\"\n  // digits have been input yet. Still, return `\"+1\"` as `value` in such cases,\n  // because otherwise the app would think that the input is empty and mark it as such\n  // while in reality it isn't empty, which might be thought of as a \"bug\", or just\n  // a \"weird\" behavior.\n  //\n  // if (partial_national_significant_number) {\n\n  return \"+\".concat(getCountryCallingCode(country, metadata)).concat(partial_national_significant_number || ''); // }\n}\n/**\r\n * Trims phone number digits if they exceed the maximum possible length\r\n * for a national (significant) number for the country.\r\n * @param  {string} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string} country\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} Can be empty.\r\n */\n\nexport function trimNumber(number, country, metadata) {\n  var nationalSignificantNumberPart = getNationalSignificantNumberDigits(number, country, metadata);\n  if (nationalSignificantNumberPart) {\n    var overflowDigitsCount = nationalSignificantNumberPart.length - getMaxNumberLength(country, metadata);\n    if (overflowDigitsCount > 0) {\n      return number.slice(0, number.length - overflowDigitsCount);\n    }\n  }\n  return number;\n}\nfunction getMaxNumberLength(country, metadata) {\n  // Get \"possible lengths\" for a phone number of the country.\n  metadata = new Metadata(metadata);\n  metadata.selectNumberingPlan(country); // Return the last \"possible length\".\n\n  return metadata.numberingPlan.possibleLengths()[metadata.numberingPlan.possibleLengths().length - 1];\n} // If the phone number being input is an international one\n// then tries to derive the country from the phone number.\n// (regardless of whether there's any country currently selected)\n\n/**\r\n * @param {string} partialE164Number - A possibly incomplete E.164 phone number.\r\n * @param {string?} country - Currently selected country.\r\n * @param {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\nexport function getCountryForPartialE164Number(partialE164Number, _ref4) {\n  var country = _ref4.country,\n    countries = _ref4.countries,\n    required = _ref4.required,\n    metadata = _ref4.metadata;\n  if (partialE164Number === '+') {\n    // Don't change the currently selected country yet.\n    return country;\n  }\n  var derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(partialE164Number, metadata); // If a phone number is being input in international form\n  // and the country can already be derived from it,\n  // then select that country.\n\n  if (derived_country && (!countries || countries.indexOf(derived_country) >= 0)) {\n    return derived_country;\n  } // If \"International\" country option has not been disabled\n  // and the international phone number entered doesn't correspond\n  // to the currently selected country then reset the currently selected country.\n  else if (country && !required && !couldNumberBelongToCountry(partialE164Number, country, metadata)) {\n    return undefined;\n  } // Don't change the currently selected country.\n\n  return country;\n}\n/**\r\n * Parses `<input/>` value. Derives `country` from `input`. Derives an E.164 `value`.\r\n * @param  {string?} phoneDigits — Parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} prevPhoneDigits — Previous parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} country - Currently selected country.\r\n * @param  {boolean} countryRequired - Is selecting some country required.\r\n * @param  {function} getAnyCountry - Can be used to get any country when selecting some country required.\r\n * @param  {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param  {boolean} international - Set to `true` to force international phone number format (leading `+`). Set to `false` to force \"national\" phone number format. Is `undefined` by default.\r\n * @param  {boolean} limitMaxLength — Whether to enable limiting phone number max length.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {object} An object of shape `{ input, country, value }`.\r\n */\n\nexport function onPhoneDigitsChange(phoneDigits, _ref5) {\n  var prevPhoneDigits = _ref5.prevPhoneDigits,\n    country = _ref5.country,\n    defaultCountry = _ref5.defaultCountry,\n    countryRequired = _ref5.countryRequired,\n    getAnyCountry = _ref5.getAnyCountry,\n    countries = _ref5.countries,\n    international = _ref5.international,\n    limitMaxLength = _ref5.limitMaxLength,\n    countryCallingCodeEditable = _ref5.countryCallingCodeEditable,\n    metadata = _ref5.metadata;\n  if (international && countryCallingCodeEditable === false) {\n    if (country) {\n      // For international phone numbers written with non-editable country calling code,\n      // the `<input/>` value must always start with that non-editable country calling code.\n      var prefix = getInternationalPhoneNumberPrefix(country, metadata); // If the input value doesn't start with the non-editable country calling code,\n      // it should be fixed.\n\n      if (phoneDigits.indexOf(prefix) !== 0) {\n        var _value; // If a phone number input is declared as\n        // `international: true` and `countryCallingCodeEditable: false`,\n        // then the value of the `<input/>` is gonna be non-empty at all times,\n        // even before the user has started to input any digits in the input field,\n        // because the country calling code is always there by design.\n        //\n        // The fact that the input value is always non-empty results in a side effect:\n        // whenever a user tabs into such input field, its value gets automatically selected.\n        // If at that moment in time the user starts typing in the national digits of the phone number,\n        // the selected `<input/>` value gets automatically replaced by those typed-in digits\n        // so the value changes from `+xxx` to `y`, because inputting anything while having\n        // the `<input/>` value selected results in erasing that `<input/>` value.\n        //\n        // This component handles such cases by restoring the `<input/>` value to what\n        // it should be in such cases: `+xxxy`.\n        // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\n        //\n\n        var hasStartedTypingInNationalNumberDigitsHavingInputValueSelected = phoneDigits && phoneDigits[0] !== '+';\n        if (hasStartedTypingInNationalNumberDigitsHavingInputValueSelected) {\n          // Fix the input value to what it should be: `y` → `+xxxy`.\n          phoneDigits = prefix + phoneDigits;\n          _value = e164(phoneDigits, country, metadata);\n        } else {\n          // In other cases, simply reset the `<input/>` value, because there're only two\n          // possible cases:\n          // * The user has selected the `<input/>` value and then hit Delete/Backspace to erase it.\n          // * The user has pasted an international phone number for another country calling code,\n          //   which is considered a non-valid value.\n          phoneDigits = prefix;\n        }\n        return {\n          phoneDigits: phoneDigits,\n          value: _value,\n          country: country\n        };\n      }\n    }\n  } // If `international` property is `false`, then it means\n  // \"enforce national-only format during input\",\n  // so, if that's the case, then remove all `+` characters,\n  // but only if some country is currently selected.\n  // (not if \"International\" country is selected).\n\n  if (international === false && country && phoneDigits && phoneDigits[0] === '+') {\n    phoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata);\n  } // Trim the input to not exceed the maximum possible number length.\n\n  if (phoneDigits && country && limitMaxLength) {\n    phoneDigits = trimNumber(phoneDigits, country, metadata);\n  } // If this `onChange()` event was triggered\n  // as a result of selecting \"International\" country,\n  // then force-prepend a `+` sign if the phone number\n  // `<input/>` value isn't in international format.\n  // Also, force-prepend a `+` sign if international\n  // phone number input format is set.\n\n  if (phoneDigits && phoneDigits[0] !== '+' && (!country || international)) {\n    phoneDigits = '+' + phoneDigits;\n  } // If the previously entered phone number\n  // has been entered in international format\n  // and the user decides to erase it,\n  // then also reset the `country`\n  // because it was most likely automatically selected\n  // while the user was typing in the phone number\n  // in international format.\n  // This fixes the issue when a user is presented\n  // with a phone number input with no country selected\n  // and then types in their local phone number\n  // then discovers that the input's messed up\n  // (a `+` has been prepended at the start of their input\n  //  and a random country has been selected),\n  // decides to undo it all by erasing everything\n  // and then types in their local phone number again\n  // resulting in a seemingly correct phone number\n  // but in reality that phone number has incorrect country.\n  // https://github.com/catamphetamine/react-phone-number-input/issues/273\n\n  if (!phoneDigits && prevPhoneDigits && prevPhoneDigits[0] === '+') {\n    if (international) {\n      country = undefined;\n    } else {\n      country = defaultCountry;\n    }\n  } // Also resets such \"randomly\" selected country\n  // as soon as the user erases the number\n  // digit-by-digit up to the leading `+` sign.\n\n  if (phoneDigits === '+' && prevPhoneDigits && prevPhoneDigits[0] === '+' && prevPhoneDigits.length > '+'.length) {\n    country = undefined;\n  } // Generate the new `value` property.\n\n  var value;\n  if (phoneDigits) {\n    if (phoneDigits[0] === '+') {\n      if (phoneDigits === '+') {\n        value = undefined;\n      } else if (country && getInternationalPhoneNumberPrefix(country, metadata).indexOf(phoneDigits) === 0) {\n        // Selected a `country` and started inputting an\n        // international phone number for this country\n        // but hasn't input any \"national (significant) number\" digits yet.\n        // In that case, assume `value` be `undefined`.\n        //\n        // For example, if selected `country` `\"US\"`\n        // and started inputting phone number `\"+1\"`\n        // then `value` `undefined` will be returned from this function.\n        //\n        value = undefined;\n      } else {\n        value = e164(phoneDigits, country, metadata);\n      }\n    } else {\n      value = e164(phoneDigits, country, metadata);\n    }\n  } // Derive the country from the phone number.\n  // (regardless of whether there's any country currently selected,\n  //  because there could be several countries corresponding to one country calling code)\n\n  if (value) {\n    country = getCountryForPartialE164Number(value, {\n      country: country,\n      countries: countries,\n      metadata: metadata\n    }); // If `international` property is `false`, then it means\n    // \"enforce national-only format during input\",\n    // so, if that's the case, then remove all `+` characters,\n    // but only if some country is currently selected.\n    // (not if \"International\" country is selected).\n\n    if (international === false && country && phoneDigits && phoneDigits[0] === '+') {\n      phoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata); // Re-calculate `value` because `phoneDigits` has changed.\n\n      value = e164(phoneDigits, country, metadata);\n    }\n  }\n  if (!country && countryRequired) {\n    country = defaultCountry || getAnyCountry();\n  }\n  return {\n    phoneDigits: phoneDigits,\n    country: country,\n    value: value\n  };\n}\nfunction convertInternationalPhoneDigitsToNational(input, country, metadata) {\n  // Handle the case when a user might have pasted\n  // a phone number in international format.\n  if (input.indexOf(getInternationalPhoneNumberPrefix(country, metadata)) === 0) {\n    // Create \"as you type\" formatter.\n    var formatter = new AsYouType(country, metadata); // Input partial national phone number.\n\n    formatter.input(input); // Return the parsed partial national phone number.\n\n    var phoneNumber = formatter.getNumber();\n    if (phoneNumber) {\n      // Transform the number to a national one,\n      // and remove all non-digits.\n      return phoneNumber.formatNational().replace(/\\D/g, '');\n    } else {\n      return '';\n    }\n  } else {\n    // Just remove the `+` sign.\n    return input.replace(/\\D/g, '');\n  }\n}\n/**\r\n * Determines the country for a given (possibly incomplete) E.164 phone number.\r\n * @param  {string} number - A possibly incomplete E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\nexport function getCountryFromPossiblyIncompleteInternationalPhoneNumber(number, metadata) {\n  var formatter = new AsYouType(null, metadata);\n  formatter.input(number); // // `001` is a special \"non-geograpical entity\" code\n  // // in Google's `libphonenumber` library.\n  // if (formatter.getCountry() === '001') {\n  // \treturn\n  // }\n\n  return formatter.getCountry();\n}\n/**\r\n * Compares two strings.\r\n * A helper for `Array.sort()`.\r\n * @param {string} a — First string.\r\n * @param {string} b — Second string.\r\n * @param {(string[]|string)} [locales] — The `locales` argument of `String.localeCompare`.\r\n */\n\nexport function compareStrings(a, b, locales) {\n  // Use `String.localeCompare` if it's available.\n  // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\n  // Which means everyone except IE <= 10 and Safari <= 10.\n  // `localeCompare()` is available in latest Node.js versions.\n\n  /* istanbul ignore else */\n  if (String.prototype.localeCompare) {\n    return a.localeCompare(b, locales);\n  }\n  /* istanbul ignore next */\n\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n/**\r\n * Strips `+${countryCallingCode}` prefix from an E.164 phone number.\r\n * @param {string} number - (possibly incomplete) E.164 phone number.\r\n * @param {string?} country - A possible country for this phone number.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string}\r\n */\n\nexport function stripCountryCallingCode(number, country, metadata) {\n  // Just an optimization, so that it\n  // doesn't have to iterate through all country calling codes.\n  if (country) {\n    var countryCallingCodePrefix = '+' + getCountryCallingCode(country, metadata); // If `country` fits the actual `number`.\n\n    if (number.length < countryCallingCodePrefix.length) {\n      if (countryCallingCodePrefix.indexOf(number) === 0) {\n        return '';\n      }\n    } else {\n      if (number.indexOf(countryCallingCodePrefix) === 0) {\n        return number.slice(countryCallingCodePrefix.length);\n      }\n    }\n  } // If `country` doesn't fit the actual `number`.\n  // Try all available country calling codes.\n\n  for (var _i = 0, _Object$keys = Object.keys(metadata.country_calling_codes); _i < _Object$keys.length; _i++) {\n    var country_calling_code = _Object$keys[_i];\n    if (number.indexOf(country_calling_code) === '+'.length) {\n      return number.slice('+'.length + country_calling_code.length);\n    }\n  }\n  return '';\n}\n/**\r\n * Parses a partially entered national phone number digits\r\n * (or a partially entered E.164 international phone number)\r\n * and returns the national significant number part.\r\n * National significant number returned doesn't come with a national prefix.\r\n * @param {string} number - National number digits. Or possibly incomplete E.164 phone number.\r\n * @param {string?} country\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} [result]\r\n */\n\nexport function getNationalSignificantNumberDigits(number, country, metadata) {\n  // Create \"as you type\" formatter.\n  var formatter = new AsYouType(country, metadata); // Input partial national phone number.\n\n  formatter.input(number); // Return the parsed partial national phone number.\n\n  var phoneNumber = formatter.getNumber();\n  return phoneNumber && phoneNumber.nationalNumber;\n}\n/**\r\n * Checks if a partially entered E.164 phone number could belong to a country.\r\n * @param  {string} number\r\n * @param  {string} country\r\n * @return {boolean}\r\n */\n\nexport function couldNumberBelongToCountry(number, country, metadata) {\n  var intlPhoneNumberPrefix = getInternationalPhoneNumberPrefix(country, metadata);\n  var i = 0;\n  while (i < number.length && i < intlPhoneNumberPrefix.length) {\n    if (number[i] !== intlPhoneNumberPrefix[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n/**\r\n * Gets initial \"phone digits\" (including `+`, if using international format).\r\n * @return {string} [phoneDigits] Returns `undefined` if there should be no initial \"phone digits\".\r\n */\n\nexport function getInitialPhoneDigits(_ref6) {\n  var value = _ref6.value,\n    phoneNumber = _ref6.phoneNumber,\n    defaultCountry = _ref6.defaultCountry,\n    international = _ref6.international,\n    useNationalFormat = _ref6.useNationalFormat,\n    metadata = _ref6.metadata;\n\n  // If the `value` (E.164 phone number)\n  // belongs to the currently selected country\n  // and `useNationalFormat` is `true`\n  // then convert `value` (E.164 phone number)\n  // to a local phone number digits.\n  // E.g. '+78005553535' -> '88005553535'.\n  if ((international === false || useNationalFormat) && phoneNumber && phoneNumber.country) {\n    return generateNationalNumberDigits(phoneNumber);\n  } // If `international` property is `true`,\n  // meaning \"enforce international phone number format\",\n  // then always show country calling code in the input field.\n\n  if (!value && international && defaultCountry) {\n    return getInternationalPhoneNumberPrefix(defaultCountry, metadata);\n  }\n  return value;\n}","map":{"version":3,"names":["parsePhoneNumber_","getCountryCallingCode","AsYouType","Metadata","getInternationalPhoneNumberPrefix","getPreSelectedCountry","_ref","value","phoneNumber","defaultCountry","getAnyCountry","countries","required","metadata","country","couldNumberBelongToCountry","indexOf","undefined","length","getCountrySelectOptions","_ref2","countryNames","addInternationalOption","compareStringsLocales","_compareStrings","compareStrings","countrySelectOptions","map","label","sort","a","b","unshift","ZZ","parsePhoneNumber","generateNationalNumberDigits","formatNational","replace","getPhoneDigitsForNewCountry","phoneDigits","_ref3","prevCountry","newCountry","useNationalFormat","stripCountryCallingCode","newCountryPrefix","defaultValue","e164","number","asYouType","input","getNumberValue","partial_national_significant_number","getNationalSignificantNumberDigits","concat","trimNumber","nationalSignificantNumberPart","overflowDigitsCount","getMaxNumberLength","slice","selectNumberingPlan","numberingPlan","possibleLengths","getCountryForPartialE164Number","partialE164Number","_ref4","derived_country","getCountryFromPossiblyIncompleteInternationalPhoneNumber","onPhoneDigitsChange","_ref5","prevPhoneDigits","countryRequired","international","limitMaxLength","countryCallingCodeEditable","prefix","_value","hasStartedTypingInNationalNumberDigitsHavingInputValueSelected","convertInternationalPhoneDigitsToNational","formatter","getNumber","getCountry","locales","String","prototype","localeCompare","countryCallingCodePrefix","_i","_Object$keys","Object","keys","country_calling_codes","country_calling_code","nationalNumber","intlPhoneNumberPrefix","i","getInitialPhoneDigits","_ref6"],"sources":["C:/Users/rohit/OneDrive/Desktop/github_hashgate/Hashgate/node_modules/react-phone-number-input/modules/helpers/phoneInputHelpers.js"],"sourcesContent":["import parsePhoneNumber_, { getCountryCallingCode, AsYouType, Metadata } from 'libphonenumber-js/core';\nimport getInternationalPhoneNumberPrefix from './getInternationalPhoneNumberPrefix.js';\n/**\r\n * Decides which country should be pre-selected\r\n * when the phone number input component is first mounted.\r\n * @param  {object?} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {string?} country - Pre-defined country (two-letter code).\r\n * @param  {string[]?} countries - A list of countries available.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string?}\r\n */\n\nexport function getPreSelectedCountry(_ref) {\n  var value = _ref.value,\n      phoneNumber = _ref.phoneNumber,\n      defaultCountry = _ref.defaultCountry,\n      getAnyCountry = _ref.getAnyCountry,\n      countries = _ref.countries,\n      required = _ref.required,\n      metadata = _ref.metadata;\n  var country; // If can get country from E.164 phone number\n  // then it overrides the `country` passed (or not passed).\n\n  if (phoneNumber && phoneNumber.country) {\n    // `country` will be left `undefined` in case of non-detection.\n    country = phoneNumber.country;\n  } else if (defaultCountry) {\n    if (!value || couldNumberBelongToCountry(value, defaultCountry, metadata)) {\n      country = defaultCountry;\n    }\n  } // Only pre-select a country if it's in the available `countries` list.\n\n\n  if (countries && countries.indexOf(country) < 0) {\n    country = undefined;\n  } // If there will be no \"International\" option\n  // then some `country` must be selected.\n  // It will still be the wrong country though.\n  // But still country `<select/>` can't be left in a broken state.\n\n\n  if (!country && required && countries && countries.length > 0) {\n    country = getAnyCountry(); // noCountryMatchesTheNumber = true\n  }\n\n  return country;\n}\n/**\r\n * Generates a sorted list of country `<select/>` options.\r\n * @param  {string[]} countries - A list of two-letter (\"ISO 3166-1 alpha-2\") country codes.\r\n * @param  {object} labels - Custom country labels. E.g. `{ RU: 'Россия', US: 'США', ... }`.\r\n * @param  {boolean} addInternationalOption - Whether should include \"International\" option at the top of the list.\r\n * @return {object[]} A list of objects having shape `{ value : string, label : string }`.\r\n */\n\nexport function getCountrySelectOptions(_ref2) {\n  var countries = _ref2.countries,\n      countryNames = _ref2.countryNames,\n      addInternationalOption = _ref2.addInternationalOption,\n      compareStringsLocales = _ref2.compareStringsLocales,\n      _compareStrings = _ref2.compareStrings;\n\n  // Default country name comparator uses `String.localeCompare()`.\n  if (!_compareStrings) {\n    _compareStrings = compareStrings;\n  } // Generates a `<Select/>` option for each country.\n\n\n  var countrySelectOptions = countries.map(function (country) {\n    return {\n      value: country,\n      // All `locale` country names included in this library\n      // include all countries (this is checked at build time).\n      // The only case when a country name might be missing\n      // is when a developer supplies their own `labels` property.\n      // To guard against such cases, a missing country name\n      // is substituted by country code.\n      label: countryNames[country] || country\n    };\n  }); // Sort the list of countries alphabetically.\n\n  countrySelectOptions.sort(function (a, b) {\n    return _compareStrings(a.label, b.label, compareStringsLocales);\n  }); // Add the \"International\" option to the country list (if suitable)\n\n  if (addInternationalOption) {\n    countrySelectOptions.unshift({\n      label: countryNames.ZZ\n    });\n  }\n\n  return countrySelectOptions;\n}\n/**\r\n * Parses a E.164 phone number to an instance of `PhoneNumber` class.\r\n * @param {string?} value = E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {object} Object having shape `{ country: string?, countryCallingCode: string, number: string }`. `PhoneNumber`: https://gitlab.com/catamphetamine/libphonenumber-js#phonenumber.\r\n * @example\r\n * parsePhoneNumber('+78005553535')\r\n */\n\nexport function parsePhoneNumber(value, metadata) {\n  return parsePhoneNumber_(value || '', metadata);\n}\n/**\r\n * Generates national number digits for a parsed phone.\r\n * May prepend national prefix.\r\n * The phone number must be a complete and valid phone number.\r\n * @param  {object} phoneNumber - An instance of `PhoneNumber` class.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string}\r\n * @example\r\n * getNationalNumberDigits({ country: 'RU', phone: '8005553535' })\r\n * // returns '88005553535'\r\n */\n\nexport function generateNationalNumberDigits(phoneNumber) {\n  return phoneNumber.formatNational().replace(/\\D/g, '');\n}\n/**\r\n * Migrates parsed `<input/>` `value` for the newly selected `country`.\r\n * @param {string?} phoneDigits - Phone number digits (and `+`) parsed from phone number `<input/>` (it's not the same as the `value` property).\r\n * @param {string?} prevCountry - Previously selected country.\r\n * @param {string?} newCountry - Newly selected country. Can't be same as previously selected country.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @param {boolean} useNationalFormat - whether should attempt to convert from international to national number for the new country.\r\n * @return {string?}\r\n */\n\nexport function getPhoneDigitsForNewCountry(phoneDigits, _ref3) {\n  var prevCountry = _ref3.prevCountry,\n      newCountry = _ref3.newCountry,\n      metadata = _ref3.metadata,\n      useNationalFormat = _ref3.useNationalFormat;\n\n  if (prevCountry === newCountry) {\n    return phoneDigits;\n  } // If `parsed_input` is empty\n  // then no need to migrate anything.\n\n\n  if (!phoneDigits) {\n    if (useNationalFormat) {\n      return '';\n    } else {\n      // If `phoneDigits` is empty then set `phoneDigits` to\n      // `+{getCountryCallingCode(newCountry)}`.\n      return getInternationalPhoneNumberPrefix(newCountry, metadata);\n    }\n  } // If switching to some country.\n  // (from \"International\" or another country)\n  // If switching from \"International\" then `phoneDigits` starts with a `+`.\n  // Otherwise it may or may not start with a `+`.\n\n\n  if (newCountry) {\n    // If the phone number was entered in international format\n    // then migrate it to the newly selected country.\n    // The phone number may be incomplete.\n    // The phone number entered not necessarily starts with\n    // the previously selected country phone prefix.\n    if (phoneDigits[0] === '+') {\n      // If the international phone number is for the new country\n      // then convert it to local if required.\n      if (useNationalFormat) {\n        // // If a phone number is being input in international form\n        // // and the country can already be derived from it,\n        // // and if it is the new country, then format as a national number.\n        // const derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(phoneDigits, metadata)\n        // if (derived_country === newCountry) {\n        // \treturn stripCountryCallingCode(phoneDigits, derived_country, metadata)\n        // }\n        // Actually, the two countries don't necessarily need to match:\n        // the condition could be looser here, because several countries\n        // might share the same international phone number format\n        // (for example, \"NANPA\" countries like US, Canada, etc).\n        // The looser condition would be just \"same nternational phone number format\"\n        // which would mean \"same country calling code\" in the context of `libphonenumber-js`.\n        if (phoneDigits.indexOf('+' + getCountryCallingCode(newCountry, metadata)) === 0) {\n          return stripCountryCallingCode(phoneDigits, newCountry, metadata);\n        } // Simply discard the previously entered international phone number,\n        // because otherwise any \"smart\" transformation like getting the\n        // \"national (significant) number\" part and then prepending the\n        // newly selected country's \"country calling code\" to it\n        // would just be confusing for a user without being actually useful.\n\n\n        return ''; // // Simply strip the leading `+` character\n        // // therefore simply converting all digits into a \"local\" phone number.\n        // // https://github.com/catamphetamine/react-phone-number-input/issues/287\n        // return phoneDigits.slice(1)\n      }\n\n      if (prevCountry) {\n        var newCountryPrefix = getInternationalPhoneNumberPrefix(newCountry, metadata);\n\n        if (phoneDigits.indexOf(newCountryPrefix) === 0) {\n          return phoneDigits;\n        } else {\n          return newCountryPrefix;\n        }\n      } else {\n        var defaultValue = getInternationalPhoneNumberPrefix(newCountry, metadata); // If `phoneDigits`'s country calling code part is the same\n        // as for the new `country`, then leave `phoneDigits` as is.\n\n        if (phoneDigits.indexOf(defaultValue) === 0) {\n          return phoneDigits;\n        } // If `phoneDigits`'s country calling code part is not the same\n        // as for the new `country`, then set `phoneDigits` to\n        // `+{getCountryCallingCode(newCountry)}`.\n\n\n        return defaultValue;\n      } // // If the international phone number already contains\n      // // any country calling code then trim the country calling code part.\n      // // (that could also be the newly selected country phone code prefix as well)\n      // // `phoneDigits` doesn't neccessarily belong to `prevCountry`.\n      // // (e.g. if a user enters an international number\n      // //  not belonging to any of the reduced `countries` list).\n      // phoneDigits = stripCountryCallingCode(phoneDigits, prevCountry, metadata)\n      // // Prepend country calling code prefix\n      // // for the newly selected country.\n      // return e164(phoneDigits, newCountry, metadata) || `+${getCountryCallingCode(newCountry, metadata)}`\n\n    }\n  } // If switching to \"International\" from a country.\n  else {\n    // If the phone number was entered in national format.\n    if (phoneDigits[0] !== '+') {\n      // Format the national phone number as an international one.\n      // The phone number entered not necessarily even starts with\n      // the previously selected country phone prefix.\n      // Even if the phone number belongs to whole another country\n      // it will still be parsed into some national phone number.\n      //\n      // Ignore the now-uncovered `|| ''` code branch:\n      // previously `e164()` function could return an empty string\n      // even when `phoneDigits` were not empty.\n      // Now it always returns some `value` when there're any `phoneDigits`.\n      // Still, didn't remove the `|| ''` code branch just in case\n      // that logic changes somehow in some future, so there're no\n      // possible bugs related to that.\n      //\n      // (ignore the `|| ''` code branch)\n\n      /* istanbul ignore next */\n      return e164(phoneDigits, prevCountry, metadata) || '';\n    }\n  }\n\n  return phoneDigits;\n}\n/**\r\n * Converts phone number digits to a (possibly incomplete) E.164 phone number.\r\n * @param  {string?} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string?} country\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\nexport function e164(number, country, metadata) {\n  if (!number) {\n    return;\n  } // If the phone number is being input in international format.\n\n\n  if (number[0] === '+') {\n    // If it's just the `+` sign then return nothing.\n    if (number === '+') {\n      return;\n    } // Return a E.164 phone number.\n    //\n    // Could return `number` \"as is\" here, but there's a possibility\n    // that some user might incorrectly input an international number\n    // with a \"national prefix\". Such numbers aren't considered valid,\n    // but `libphonenumber-js` is \"forgiving\" when it comes to parsing\n    // user's input, and this input component follows that behavior.\n    //\n\n\n    var asYouType = new AsYouType(country, metadata);\n    asYouType.input(number); // This function would return `undefined` only when `number` is `\"+\"`,\n    // but at this point it is known that `number` is not `\"+\"`.\n\n    return asYouType.getNumberValue();\n  } // For non-international phone numbers\n  // an accompanying country code is required.\n  // The situation when `country` is `undefined`\n  // and a non-international phone number is passed\n  // to this function shouldn't happen.\n\n\n  if (!country) {\n    return;\n  }\n\n  var partial_national_significant_number = getNationalSignificantNumberDigits(number, country, metadata); //\n  // Even if no \"national (significant) number\" digits have been input,\n  // still return a non-`undefined` value.\n  // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/113\n  //\n  // For example, if the user has selected country `US` and entered `\"1\"`\n  // then that `\"1\"` is just a \"national prefix\" and no \"national (significant) number\"\n  // digits have been input yet. Still, return `\"+1\"` as `value` in such cases,\n  // because otherwise the app would think that the input is empty and mark it as such\n  // while in reality it isn't empty, which might be thought of as a \"bug\", or just\n  // a \"weird\" behavior.\n  //\n  // if (partial_national_significant_number) {\n\n  return \"+\".concat(getCountryCallingCode(country, metadata)).concat(partial_national_significant_number || ''); // }\n}\n/**\r\n * Trims phone number digits if they exceed the maximum possible length\r\n * for a national (significant) number for the country.\r\n * @param  {string} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string} country\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} Can be empty.\r\n */\n\nexport function trimNumber(number, country, metadata) {\n  var nationalSignificantNumberPart = getNationalSignificantNumberDigits(number, country, metadata);\n\n  if (nationalSignificantNumberPart) {\n    var overflowDigitsCount = nationalSignificantNumberPart.length - getMaxNumberLength(country, metadata);\n\n    if (overflowDigitsCount > 0) {\n      return number.slice(0, number.length - overflowDigitsCount);\n    }\n  }\n\n  return number;\n}\n\nfunction getMaxNumberLength(country, metadata) {\n  // Get \"possible lengths\" for a phone number of the country.\n  metadata = new Metadata(metadata);\n  metadata.selectNumberingPlan(country); // Return the last \"possible length\".\n\n  return metadata.numberingPlan.possibleLengths()[metadata.numberingPlan.possibleLengths().length - 1];\n} // If the phone number being input is an international one\n// then tries to derive the country from the phone number.\n// (regardless of whether there's any country currently selected)\n\n/**\r\n * @param {string} partialE164Number - A possibly incomplete E.164 phone number.\r\n * @param {string?} country - Currently selected country.\r\n * @param {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\n\nexport function getCountryForPartialE164Number(partialE164Number, _ref4) {\n  var country = _ref4.country,\n      countries = _ref4.countries,\n      required = _ref4.required,\n      metadata = _ref4.metadata;\n\n  if (partialE164Number === '+') {\n    // Don't change the currently selected country yet.\n    return country;\n  }\n\n  var derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(partialE164Number, metadata); // If a phone number is being input in international form\n  // and the country can already be derived from it,\n  // then select that country.\n\n  if (derived_country && (!countries || countries.indexOf(derived_country) >= 0)) {\n    return derived_country;\n  } // If \"International\" country option has not been disabled\n  // and the international phone number entered doesn't correspond\n  // to the currently selected country then reset the currently selected country.\n  else if (country && !required && !couldNumberBelongToCountry(partialE164Number, country, metadata)) {\n    return undefined;\n  } // Don't change the currently selected country.\n\n\n  return country;\n}\n/**\r\n * Parses `<input/>` value. Derives `country` from `input`. Derives an E.164 `value`.\r\n * @param  {string?} phoneDigits — Parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} prevPhoneDigits — Previous parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\r\n * @param  {string?} country - Currently selected country.\r\n * @param  {boolean} countryRequired - Is selecting some country required.\r\n * @param  {function} getAnyCountry - Can be used to get any country when selecting some country required.\r\n * @param  {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param  {boolean} international - Set to `true` to force international phone number format (leading `+`). Set to `false` to force \"national\" phone number format. Is `undefined` by default.\r\n * @param  {boolean} limitMaxLength — Whether to enable limiting phone number max length.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {object} An object of shape `{ input, country, value }`.\r\n */\n\nexport function onPhoneDigitsChange(phoneDigits, _ref5) {\n  var prevPhoneDigits = _ref5.prevPhoneDigits,\n      country = _ref5.country,\n      defaultCountry = _ref5.defaultCountry,\n      countryRequired = _ref5.countryRequired,\n      getAnyCountry = _ref5.getAnyCountry,\n      countries = _ref5.countries,\n      international = _ref5.international,\n      limitMaxLength = _ref5.limitMaxLength,\n      countryCallingCodeEditable = _ref5.countryCallingCodeEditable,\n      metadata = _ref5.metadata;\n\n  if (international && countryCallingCodeEditable === false) {\n    if (country) {\n      // For international phone numbers written with non-editable country calling code,\n      // the `<input/>` value must always start with that non-editable country calling code.\n      var prefix = getInternationalPhoneNumberPrefix(country, metadata); // If the input value doesn't start with the non-editable country calling code,\n      // it should be fixed.\n\n      if (phoneDigits.indexOf(prefix) !== 0) {\n        var _value; // If a phone number input is declared as\n        // `international: true` and `countryCallingCodeEditable: false`,\n        // then the value of the `<input/>` is gonna be non-empty at all times,\n        // even before the user has started to input any digits in the input field,\n        // because the country calling code is always there by design.\n        //\n        // The fact that the input value is always non-empty results in a side effect:\n        // whenever a user tabs into such input field, its value gets automatically selected.\n        // If at that moment in time the user starts typing in the national digits of the phone number,\n        // the selected `<input/>` value gets automatically replaced by those typed-in digits\n        // so the value changes from `+xxx` to `y`, because inputting anything while having\n        // the `<input/>` value selected results in erasing that `<input/>` value.\n        //\n        // This component handles such cases by restoring the `<input/>` value to what\n        // it should be in such cases: `+xxxy`.\n        // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\n        //\n\n\n        var hasStartedTypingInNationalNumberDigitsHavingInputValueSelected = phoneDigits && phoneDigits[0] !== '+';\n\n        if (hasStartedTypingInNationalNumberDigitsHavingInputValueSelected) {\n          // Fix the input value to what it should be: `y` → `+xxxy`.\n          phoneDigits = prefix + phoneDigits;\n          _value = e164(phoneDigits, country, metadata);\n        } else {\n          // In other cases, simply reset the `<input/>` value, because there're only two\n          // possible cases:\n          // * The user has selected the `<input/>` value and then hit Delete/Backspace to erase it.\n          // * The user has pasted an international phone number for another country calling code,\n          //   which is considered a non-valid value.\n          phoneDigits = prefix;\n        }\n\n        return {\n          phoneDigits: phoneDigits,\n          value: _value,\n          country: country\n        };\n      }\n    }\n  } // If `international` property is `false`, then it means\n  // \"enforce national-only format during input\",\n  // so, if that's the case, then remove all `+` characters,\n  // but only if some country is currently selected.\n  // (not if \"International\" country is selected).\n\n\n  if (international === false && country && phoneDigits && phoneDigits[0] === '+') {\n    phoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata);\n  } // Trim the input to not exceed the maximum possible number length.\n\n\n  if (phoneDigits && country && limitMaxLength) {\n    phoneDigits = trimNumber(phoneDigits, country, metadata);\n  } // If this `onChange()` event was triggered\n  // as a result of selecting \"International\" country,\n  // then force-prepend a `+` sign if the phone number\n  // `<input/>` value isn't in international format.\n  // Also, force-prepend a `+` sign if international\n  // phone number input format is set.\n\n\n  if (phoneDigits && phoneDigits[0] !== '+' && (!country || international)) {\n    phoneDigits = '+' + phoneDigits;\n  } // If the previously entered phone number\n  // has been entered in international format\n  // and the user decides to erase it,\n  // then also reset the `country`\n  // because it was most likely automatically selected\n  // while the user was typing in the phone number\n  // in international format.\n  // This fixes the issue when a user is presented\n  // with a phone number input with no country selected\n  // and then types in their local phone number\n  // then discovers that the input's messed up\n  // (a `+` has been prepended at the start of their input\n  //  and a random country has been selected),\n  // decides to undo it all by erasing everything\n  // and then types in their local phone number again\n  // resulting in a seemingly correct phone number\n  // but in reality that phone number has incorrect country.\n  // https://github.com/catamphetamine/react-phone-number-input/issues/273\n\n\n  if (!phoneDigits && prevPhoneDigits && prevPhoneDigits[0] === '+') {\n    if (international) {\n      country = undefined;\n    } else {\n      country = defaultCountry;\n    }\n  } // Also resets such \"randomly\" selected country\n  // as soon as the user erases the number\n  // digit-by-digit up to the leading `+` sign.\n\n\n  if (phoneDigits === '+' && prevPhoneDigits && prevPhoneDigits[0] === '+' && prevPhoneDigits.length > '+'.length) {\n    country = undefined;\n  } // Generate the new `value` property.\n\n\n  var value;\n\n  if (phoneDigits) {\n    if (phoneDigits[0] === '+') {\n      if (phoneDigits === '+') {\n        value = undefined;\n      } else if (country && getInternationalPhoneNumberPrefix(country, metadata).indexOf(phoneDigits) === 0) {\n        // Selected a `country` and started inputting an\n        // international phone number for this country\n        // but hasn't input any \"national (significant) number\" digits yet.\n        // In that case, assume `value` be `undefined`.\n        //\n        // For example, if selected `country` `\"US\"`\n        // and started inputting phone number `\"+1\"`\n        // then `value` `undefined` will be returned from this function.\n        //\n        value = undefined;\n      } else {\n        value = e164(phoneDigits, country, metadata);\n      }\n    } else {\n      value = e164(phoneDigits, country, metadata);\n    }\n  } // Derive the country from the phone number.\n  // (regardless of whether there's any country currently selected,\n  //  because there could be several countries corresponding to one country calling code)\n\n\n  if (value) {\n    country = getCountryForPartialE164Number(value, {\n      country: country,\n      countries: countries,\n      metadata: metadata\n    }); // If `international` property is `false`, then it means\n    // \"enforce national-only format during input\",\n    // so, if that's the case, then remove all `+` characters,\n    // but only if some country is currently selected.\n    // (not if \"International\" country is selected).\n\n    if (international === false && country && phoneDigits && phoneDigits[0] === '+') {\n      phoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata); // Re-calculate `value` because `phoneDigits` has changed.\n\n      value = e164(phoneDigits, country, metadata);\n    }\n  }\n\n  if (!country && countryRequired) {\n    country = defaultCountry || getAnyCountry();\n  }\n\n  return {\n    phoneDigits: phoneDigits,\n    country: country,\n    value: value\n  };\n}\n\nfunction convertInternationalPhoneDigitsToNational(input, country, metadata) {\n  // Handle the case when a user might have pasted\n  // a phone number in international format.\n  if (input.indexOf(getInternationalPhoneNumberPrefix(country, metadata)) === 0) {\n    // Create \"as you type\" formatter.\n    var formatter = new AsYouType(country, metadata); // Input partial national phone number.\n\n    formatter.input(input); // Return the parsed partial national phone number.\n\n    var phoneNumber = formatter.getNumber();\n\n    if (phoneNumber) {\n      // Transform the number to a national one,\n      // and remove all non-digits.\n      return phoneNumber.formatNational().replace(/\\D/g, '');\n    } else {\n      return '';\n    }\n  } else {\n    // Just remove the `+` sign.\n    return input.replace(/\\D/g, '');\n  }\n}\n/**\r\n * Determines the country for a given (possibly incomplete) E.164 phone number.\r\n * @param  {string} number - A possibly incomplete E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\n\n\nexport function getCountryFromPossiblyIncompleteInternationalPhoneNumber(number, metadata) {\n  var formatter = new AsYouType(null, metadata);\n  formatter.input(number); // // `001` is a special \"non-geograpical entity\" code\n  // // in Google's `libphonenumber` library.\n  // if (formatter.getCountry() === '001') {\n  // \treturn\n  // }\n\n  return formatter.getCountry();\n}\n/**\r\n * Compares two strings.\r\n * A helper for `Array.sort()`.\r\n * @param {string} a — First string.\r\n * @param {string} b — Second string.\r\n * @param {(string[]|string)} [locales] — The `locales` argument of `String.localeCompare`.\r\n */\n\nexport function compareStrings(a, b, locales) {\n  // Use `String.localeCompare` if it's available.\n  // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\n  // Which means everyone except IE <= 10 and Safari <= 10.\n  // `localeCompare()` is available in latest Node.js versions.\n\n  /* istanbul ignore else */\n  if (String.prototype.localeCompare) {\n    return a.localeCompare(b, locales);\n  }\n  /* istanbul ignore next */\n\n\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n/**\r\n * Strips `+${countryCallingCode}` prefix from an E.164 phone number.\r\n * @param {string} number - (possibly incomplete) E.164 phone number.\r\n * @param {string?} country - A possible country for this phone number.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string}\r\n */\n\nexport function stripCountryCallingCode(number, country, metadata) {\n  // Just an optimization, so that it\n  // doesn't have to iterate through all country calling codes.\n  if (country) {\n    var countryCallingCodePrefix = '+' + getCountryCallingCode(country, metadata); // If `country` fits the actual `number`.\n\n    if (number.length < countryCallingCodePrefix.length) {\n      if (countryCallingCodePrefix.indexOf(number) === 0) {\n        return '';\n      }\n    } else {\n      if (number.indexOf(countryCallingCodePrefix) === 0) {\n        return number.slice(countryCallingCodePrefix.length);\n      }\n    }\n  } // If `country` doesn't fit the actual `number`.\n  // Try all available country calling codes.\n\n\n  for (var _i = 0, _Object$keys = Object.keys(metadata.country_calling_codes); _i < _Object$keys.length; _i++) {\n    var country_calling_code = _Object$keys[_i];\n\n    if (number.indexOf(country_calling_code) === '+'.length) {\n      return number.slice('+'.length + country_calling_code.length);\n    }\n  }\n\n  return '';\n}\n/**\r\n * Parses a partially entered national phone number digits\r\n * (or a partially entered E.164 international phone number)\r\n * and returns the national significant number part.\r\n * National significant number returned doesn't come with a national prefix.\r\n * @param {string} number - National number digits. Or possibly incomplete E.164 phone number.\r\n * @param {string?} country\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string} [result]\r\n */\n\nexport function getNationalSignificantNumberDigits(number, country, metadata) {\n  // Create \"as you type\" formatter.\n  var formatter = new AsYouType(country, metadata); // Input partial national phone number.\n\n  formatter.input(number); // Return the parsed partial national phone number.\n\n  var phoneNumber = formatter.getNumber();\n  return phoneNumber && phoneNumber.nationalNumber;\n}\n/**\r\n * Checks if a partially entered E.164 phone number could belong to a country.\r\n * @param  {string} number\r\n * @param  {string} country\r\n * @return {boolean}\r\n */\n\nexport function couldNumberBelongToCountry(number, country, metadata) {\n  var intlPhoneNumberPrefix = getInternationalPhoneNumberPrefix(country, metadata);\n  var i = 0;\n\n  while (i < number.length && i < intlPhoneNumberPrefix.length) {\n    if (number[i] !== intlPhoneNumberPrefix[i]) {\n      return false;\n    }\n\n    i++;\n  }\n\n  return true;\n}\n/**\r\n * Gets initial \"phone digits\" (including `+`, if using international format).\r\n * @return {string} [phoneDigits] Returns `undefined` if there should be no initial \"phone digits\".\r\n */\n\nexport function getInitialPhoneDigits(_ref6) {\n  var value = _ref6.value,\n      phoneNumber = _ref6.phoneNumber,\n      defaultCountry = _ref6.defaultCountry,\n      international = _ref6.international,\n      useNationalFormat = _ref6.useNationalFormat,\n      metadata = _ref6.metadata;\n\n  // If the `value` (E.164 phone number)\n  // belongs to the currently selected country\n  // and `useNationalFormat` is `true`\n  // then convert `value` (E.164 phone number)\n  // to a local phone number digits.\n  // E.g. '+78005553535' -> '88005553535'.\n  if ((international === false || useNationalFormat) && phoneNumber && phoneNumber.country) {\n    return generateNationalNumberDigits(phoneNumber);\n  } // If `international` property is `true`,\n  // meaning \"enforce international phone number format\",\n  // then always show country calling code in the input field.\n\n\n  if (!value && international && defaultCountry) {\n    return getInternationalPhoneNumberPrefix(defaultCountry, metadata);\n  }\n\n  return value;\n}\n//# sourceMappingURL=phoneInputHelpers.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}